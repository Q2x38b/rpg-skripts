# =========================================================
#  TAB + LEVELS + RANKS + SCOREBOARD + CURRENCY
#  File: tab_levels_ranks.sk
# =========================================================

options:
  tab_update_seconds: 2
  sb_update_seconds: 2
  anim_seconds: 1
  actionbar_update_seconds: 1

  # Custom RPG resources
  health_base: 100
  health_per_level: 5
  health_regen: 2
  mana_base: 100
  mana_per_level: 4
  mana_regen: 3

  actionbar_resources_format: &c❤ {health}/{max_health} &8• &b✦ {mana}/{max_mana}

  chat_separator: &8 » &f

  # Level is ONLY brackets
  level_bracket_format: &8[&f{level}&8]&r

  # Keep this as a simple space (no reset), so name can inherit rank color cleanly
  rank_suffix_space: " "

  # Action bar XP: ONLY gain + remaining
  actionbar_xp_format: &a+{gain} XP &8| &7{remain} XP to next

  # Level up rewards
  levelup_coin_base: 25
  levelup_coin_per_level: 10

  # XP scaling
  xp_base: 50
  xp_linear: 25
  xp_power: 2
  xp_exponent: 3

  # XP gains
  xp_gain_mining: 4
  xp_gain_fishing: 8
  xp_gain_combat: 10

  # Currency (optional: you can later add rewards)
  admin_perm: tablevels.admin

  # GUI
  level_gui_title: "&8Skyblock Progression"
  level_gui_bar_length: 20

  # Server display
  server_name: "&a&lMyServer"

# --------------------------
#  UTIL
# --------------------------

function cc(t: text) :: text:
  return colored {_t}

function uid(p: player) :: text:
  return "%uuid of {_p}%"

function normMat(t: text) :: text:
  set {_x} to lowercase {_t}
  replace all "_" with " " in {_x}
  return {_x}

# Extract first color code like "&a" from a string, else "&f"
function firstColorCode(t: text) :: text:
  set {_s} to {_t}
  set {_i} to 1
  while {_i} <= length of {_s}:
    if character {_i} of {_s} is "&":
      if {_i} + 1 <= length of {_s}:
        set {_c} to character {_i + 1} of {_s}
        return "&%{_c}%"
    add 1 to {_i}
  return "&f"

# --------------------------
#  RPG RESOURCES
# --------------------------

function maxHealth(p: player) :: number:
  set {_lvl} to getLevel({_p})
  set {_max} to {@health_base} + (({_lvl} - 1) * {@health_per_level})
  return {_max}

function maxMana(p: player) :: number:
  set {_lvl} to getLevel({_p})
  set {_max} to {@mana_base} + (({_lvl} - 1) * {@mana_per_level})
  return {_max}

function getHealth(p: player) :: number:
  set {_u} to uid({_p})
  if {rpg_health::%{_u}%} is not set:
    set {rpg_health::%{_u}%} to maxHealth({_p})
  return {rpg_health::%{_u}%}

function getMana(p: player) :: number:
  set {_u} to uid({_p})
  if {rpg_mana::%{_u}%} is not set:
    set {rpg_mana::%{_u}%} to maxMana({_p})
  return {rpg_mana::%{_u}%}

function setHealth(p: player, amount: number):
  set {_max} to maxHealth({_p})
  set {_new} to {_amount}
  if {_new} > {_max}:
    set {_new} to {_max}
  if {_new} < 0:
    set {_new} to 0
  set {rpg_health::%uid({_p})%} to {_new}

function setMana(p: player, amount: number):
  set {_max} to maxMana({_p})
  set {_new} to {_amount}
  if {_new} > {_max}:
    set {_new} to {_max}
  if {_new} < 0:
    set {_new} to 0
  set {rpg_mana::%uid({_p})%} to {_new}

function regenResources(p: player):
  setHealth({_p}, getHealth({_p}) + {@health_regen})
  setMana({_p}, getMana({_p}) + {@mana_regen})

function levelCoinReward(lvl: number) :: number:
  set {_lvl} to {_lvl} parsed as number
  return {@levelup_coin_base} + ({_lvl} * {@levelup_coin_per_level})

function buildProgressBar(progress: number, length: number) :: text:
  set {_bar} to ""
  set {_filled} to floor(({_progress} / 100) * {_length})
  if {_filled} < 0:
    set {_filled} to 0
  if {_filled} > {_length}:
    set {_filled} to {_length}

  loop {_length} times:
    if loop-number <= {_filled}:
      set {_bar} to "%{_bar}%&a▮"
    else:
      set {_bar} to "%{_bar}%&8▮"
  return {_bar}

# --------------------------
#  LEVEL SYSTEM
# --------------------------

function getLevel(p: player) :: number:
  set {_u} to uid({_p})
  if {lvl::%{_u}%} is not set:
    set {lvl::%{_u}%} to 1
  return {lvl::%{_u}%}

function getXP(p: player) :: number:
  set {_u} to uid({_p})
  if {xp::%{_u}%} is not set:
    set {xp::%{_u}%} to 0
  return {xp::%{_u}%}

function requiredXP(lvl: number) :: number:
  set {_lvl} to {_lvl} parsed as number

  set {_pow} to 1
  loop {@xp_power} times:
    set {_pow} to {_pow} * {_lvl}

  set {_need} to {@xp_base} + ({_lvl} * {@xp_linear}) + ({_pow} * {@xp_exponent})
  return {_need}

function levelBracketRaw(p: player) :: text:
  set {_lvl} to getLevel({_p})
  set {_color} to levelColorCode({_lvl})
  set {_s} to "{@level_bracket_format}"
  replace all "{level}" with "%{_color}%%{_lvl}%&8" in {_s}
  return {_s}

# --------------------------
#  RANK SYSTEM
# --------------------------

function rankMode() :: text:
  if {rankmode} is not set:
    set {rankmode} to "stored"
  return {rankmode}

function defaultRank() :: text:
  if {rank_default} is not set:
    set {rank_default} to "member"
  return {rank_default}

function getRankName(p: player) :: text:
  set {_mode} to rankMode()
  set {_def} to defaultRank()

  if {_mode} is "permission":
    set {_best} to {_def}
    set {_bestPrio} to -999999
    loop {ranks::list::*}:
      set {_r} to loop-value
      set {_perm} to {ranks::%{_r}%::perm}
      if {_perm} is set:
        if {_p} has permission {_perm}:
          set {_prio} to {ranks::%{_r}%::priority}
          if {_prio} is not set:
            set {_prio} to 0
          if {_prio} > {_bestPrio}:
            set {_bestPrio} to {_prio}
            set {_best} to {_r}
    return {_best}

  set {_u} to uid({_p})
  if {rank::%{_u}%} is set:
    return {rank::%{_u}%}
  return {_def}

function rankPrefixRaw(p: player) :: text:
  set {_r} to getRankName({_p})
  set {_pref} to ""

  if {ranks::%{_r}%::prefix} is set:
    set {_pref} to {ranks::%{_r}%::prefix}
  else:
    set {_def} to defaultRank()
    set {_pref} to {ranks::%{_def}%::prefix}

  return "%{_pref}%{@rank_suffix_space}"

# Rank before level
function fullPrefixRaw(p: player) :: text:
  return "%rankPrefixRaw({_p})%%levelBracketRaw({_p})%"

function nameColorFromRank(p: player) :: text:
  set {_pref} to rankPrefixRaw({_p})
  return firstColorCode({_pref})

# --------------------------
#  ACTION BAR XP DISPLAY
# --------------------------

function resourceActionbarText(p: player) :: text:
  set {_h} to round getHealth({_p})
  set {_mh} to maxHealth({_p})
  set {_m} to round getMana({_p})
  set {_mm} to maxMana({_p})

  set {_mText} to "{@actionbar_resources_format}"
  replace all "{health}" with "%{_h}%" in {_mText}
  replace all "{max_health}" with "%{_mh}%" in {_mText}
  replace all "{mana}" with "%{_m}%" in {_mText}
  replace all "{max_mana}" with "%{_mm}%" in {_mText}
  return {_mText}

function showResourceActionbar(p: player):
  set {_u} to uid({_p})
  if {actionbar::lock::%{_u}%} is set:
    stop
  send action bar cc(resourceActionbarText({_p})) to {_p}

function showXPGainActionbar(p: player, gain: number):
  set {_lvl} to getLevel({_p})
  set {_xp} to getXP({_p})
  set {_need} to requiredXP({_lvl})
  set {_remain} to {_need} - {_xp}
  if {_remain} < 0:
    set {_remain} to 0

  set {_m} to "{@actionbar_xp_format}"
  replace all "{gain}" with "%{_gain}%" in {_m}
  replace all "{remain}" with "%{_remain}%" in {_m}
  set {actionbar::lock::%uid({_p})%} to true
  send action bar cc({_m}) to {_p}
  wait 2 seconds
  delete {actionbar::lock::%uid({_p})%}
  showResourceActionbar({_p})

# --------------------------
#  XP CORE
# --------------------------

function addXP(p: player, amount: number):
  if {_amount} <= 0:
    stop

  set {_u} to uid({_p})
  if {xp::%{_u}%} is not set:
    set {xp::%{_u}%} to 0
  if {lvl::%{_u}%} is not set:
    set {lvl::%{_u}%} to 1

  add {_amount} to {xp::%{_u}%}

  while {xp::%{_u}%} >= requiredXP({lvl::%{_u}%}):
    remove requiredXP({lvl::%{_u}%}) from {xp::%{_u}%}
    add 1 to {lvl::%{_u}%}
    set {_newLvl} to {lvl::%{_u}%}
    set {_reward} to levelCoinReward({_newLvl})
    if {coins::%{_u}%} is not set:
      set {coins::%{_u}%} to 0
    add {_reward} to {coins::%{_u}%}
    setHealth({_p}, maxHealth({_p}))
    setMana({_p}, maxMana({_p}))
    applyScoreboard({_p})
    send cc("&6&lLEVEL UP! &7You reached %levelBracketRaw({_p})%&7.") to {_p}
    send cc(" &8» &aRewards: &e+%{_reward}% Coins &8| &cFull Health &8| &bFull Mana") to {_p}

  showXPGainActionbar({_p}, {_amount})

# --------------------------
#  TAB APPLY (simplified + green + animation)
# --------------------------

function applyTab(p: player):
  # Build header/footer from stored lines
  set {_header} to ""
  loop {tab::header::*}:
    if {_header} is "":
      set {_header} to loop-value
    else:
      set {_header} to "%{_header}%%nl%%loop-value%"

  set {_footer} to ""
  loop {tab::footer::*}:
    if {_footer} is "":
      set {_footer} to loop-value
    else:
      set {_footer} to "%{_footer}%%nl%%loop-value%"

  set {_pname} to name of {_p}
  set {_world} to "%world of {_p}%"
  set {_online} to "%size of all players%"
  set {_anim} to animToken()

  replace all "{anim}" with {_anim} in {_header}
  replace all "{player}" with "%{_pname}%" in {_header}
  replace all "{world}" with "%{_world}%" in {_header}
  replace all "{online}" with "%{_online}%" in {_header}

  replace all "{anim}" with {_anim} in {_footer}
  replace all "{player}" with "%{_pname}%" in {_footer}
  replace all "{world}" with "%{_world}%" in {_footer}
  replace all "{online}" with "%{_online}%" in {_footer}

  set {_p}'s tab list header to cc({_header})
  set {_p}'s tab list footer to cc({_footer})

  # Name color = rank color
  set {_pref} to cc(fullPrefixRaw({_p}))
  set {_namec} to nameColorFromRank({_p})

  set {_p}'s tab list name to "%{_pref}% %{_namec}%%name of {_p}%"

# --------------------------
#  SCOREBOARD (styled like tab)
# --------------------------

function getCoins(p: player) :: number:
  set {_u} to uid({_p})
  if {coins::%{_u}%} is not set:
    set {coins::%{_u}%} to 0
  return {coins::%{_u}%}

function getGems(p: player) :: number:
  set {_u} to uid({_p})
  if {gems::%{_u}%} is not set:
    set {gems::%{_u}%} to 0
  return {gems::%{_u}%}

function applyScoreboard(p: player):
  # Some Skript builds use "wipe sidebar of player" + "set score ... in sidebar of player"
  wipe sidebar of {_p}

  set {_anim} to animToken()
  set {_title} to cc("&a%{_anim}% &fStats")
  set name of sidebar of {_p} to {_title}

  set {_u} to uid({_p})
  if {coins::%{_u}%} is not set:
    set {coins::%{_u}%} to 0
  if {gems::%{_u}%} is not set:
    set {gems::%{_u}%} to 0

  set {_coins} to {coins::%{_u}%}
  set {_gems} to {gems::%{_u}%}

  set {_lvl} to getLevel({_p})
  set {_xp} to getXP({_p})
  set {_need} to requiredXP({_lvl})

  # Lines MUST be unique; use tiny trailing color codes for uniqueness
    set score cc("&8 ") in sidebar of {_p} to 8
    set score cc("&aCoins: &f%{_coins}%&r") in sidebar of {_p} to 7
    set score cc("&aGems:  &f%{_gems}%&r&0") in sidebar of {_p} to 6
    set score cc("&8  ") in sidebar of {_p} to 5
    set score cc("&7Level: &f%levelBracketRaw({_p})%&r&1") in sidebar of {_p} to 4
    set score cc("&7XP: &f%{_xp}%&7/&f%{_need}%&r&2") in sidebar of {_p} to 3
    set score cc("&8   ") in sidebar of {_p} to 2
    set score cc("&7Online: &a%size of all players%&r&3") in sidebar of {_p} to 1

# --------------------------
#  DEFAULT DATA (TAB LOOK)
# --------------------------

on load:
  # Simple green-styled tab. No top divider. Server + welcome are separate lines.
  if {tab::header::1} is not set:
    delete {tab::header::*}
    set {tab::header::1} to "{anim} {@server_name}"
    set {tab::header::2} to "&7Welcome, &f{player}"
    set {tab::header::3} to "&7Online: &a{online} &8• &7World: &a{world}"

  if {tab::footer::1} is not set:
    delete {tab::footer::*}
    set {tab::footer::1} to "&7Use &a/mystats &7for details"

  if {rankmode} is not set:
    set {rankmode} to "stored"
  if {rank_default} is not set:
    set {rank_default} to "member"

  # Default ranks
  if {ranks::list::1} is not set:
    delete {ranks::list::*}

    add "member" to {ranks::list::*}
    set {ranks::member::priority} to 0
    set {ranks::member::prefix} to "&7Member"

    add "vip" to {ranks::list::*}
    set {ranks::vip::priority} to 10
    set {ranks::vip::prefix} to "&6VIP"
    set {ranks::vip::perm} to "rank.vip"

    add "mod" to {ranks::list::*}
    set {ranks::mod::priority} to 50
    set {ranks::mod::prefix} to "&2Mod"
    set {ranks::mod::perm} to "rank.mod"

    add "admin" to {ranks::list::*}
    set {ranks::admin::priority} to 100
    set {ranks::admin::prefix} to "&cAdmin"
    set {ranks::admin::perm} to "rank.admin"

  # Default mining blocks
  if {xp::mine::blocks::1} is not set:
    delete {xp::mine::blocks::*}
    add "stone" to {xp::mine::blocks::*}
    add "deepslate" to {xp::mine::blocks::*}
    add "coal ore" to {xp::mine::blocks::*}
    add "iron ore" to {xp::mine::blocks::*}
    add "gold ore" to {xp::mine::blocks::*}
    add "diamond ore" to {xp::mine::blocks::*}
    add "ancient debris" to {xp::mine::blocks::*}

# --------------------------
#  ANIMATION TICK
# --------------------------

every {@anim_seconds} seconds:
  if {anim::step} is not set:
    set {anim::step} to 1
  add 1 to {anim::step}
  if {anim::step} > 4:
    set {anim::step} to 1

# --------------------------
#  UPDATERS
# --------------------------

on join:
  setHealth(player, maxHealth(player))
  setMana(player, maxMana(player))
  applyTab(player)
  applyScoreboard(player)
  showResourceActionbar(player)

every {@tab_update_seconds} seconds:
  loop all players:
    applyTab(loop-player)

every {@sb_update_seconds} seconds:
  loop all players:
    applyScoreboard(loop-player)

every {@actionbar_update_seconds} seconds:
  loop all players:
    regenResources(loop-player)
    showResourceActionbar(loop-player)

# --------------------------
#  XP EVENTS
# --------------------------

on break:
  if gamemode of player is creative:
    stop
  set {_mat} to normMat("%type of event-block%")
  if {_mat} is in {xp::mine::blocks::*}:
    addXP(player, {@xp_gain_mining})

on fishing state change:
  if event-fishing state is fish caught:
    if gamemode of player is creative:
      stop
    addXP(player, {@xp_gain_fishing})

on death:
  if attacker is a player:
    if victim is a player:
      stop
    if gamemode of attacker is creative:
      stop
    addXP(attacker, {@xp_gain_combat})

# --------------------------
#  CHAT FORMAT (rank before level; name colored like rank)
# --------------------------

on chat:
  set {_pref} to cc(fullPrefixRaw(player))
  set {_namec} to nameColorFromRank(player)
  set chat format to "%{_pref}% %{_namec}%[player]{@chat_separator}[message]"

# =========================================================
#  COMMANDS
# =========================================================

command /mystats:
  trigger:
    set {_lvl} to getLevel(player)
    set {_xp} to getXP(player)
    set {_need} to requiredXP({_lvl})
    set {_remain} to {_need} - {_xp}
    if {_remain} < 0:
      set {_remain} to 0
    send cc("&7Level: &f%levelBracketRaw(player)% &8| &7XP: &f%{_xp}%&7/&f%{_need}% &8| &7Next in &f%{_remain}%") to player

function openLevelMenu(p: player):
  set {_lvl} to getLevel({_p})
  set {_xp} to getXP({_p})
  set {_need} to requiredXP({_lvl})
  if {_need} <= 0:
    set {_need} to 1
  set {_progress} to floor(({_xp} / {_need}) * 100)
  if {_progress} > 100:
    set {_progress} to 100
  if {_progress} < 0:
    set {_progress} to 0

  set {_bar} to buildProgressBar({_progress}, {@level_gui_bar_length})
  set {_title} to cc("{@level_gui_title}")
  open chest inventory with size 54 named {_title} to {_p}
  wait 2 ticks

  loop 0 to 53:
    format slot loop-number of {_p} with gray stained glass pane named " " to do nothing

  format slot 13 of {_p} with nether star named cc("&a&lYour Level") with lore cc("&7Level: &f%levelBracketRaw({_p})%"), cc("&7Progress: &f%{_progress}%&7%%"), cc("&a%{_bar}%"), cc("&7XP: &f%{_xp}%&7/&f%{_need}%") to do nothing
  format slot 29 of {_p} with red dye named cc("&cHealth") with lore cc("&7Max: &f%maxHealth({_p})%"), cc("&7Current: &f%getHealth({_p})%") to do nothing
  format slot 31 of {_p} with gold ingot named cc("&6Coins") with lore cc("&7Balance: &f%getCoins({_p})%"), cc("&7Next reward: &e+%levelCoinReward({_lvl} + 1)% Coins") to do nothing
  format slot 33 of {_p} with light blue dye named cc("&bMana") with lore cc("&7Max: &f%maxMana({_p})%"), cc("&7Current: &f%getMana({_p})%") to do nothing

command /levelmenu:
  trigger:
    openLevelMenu(player)

command /levelgui:
  trigger:
    openLevelMenu(player)

# Coins / Gems admin
command /coinsgive <player> <number>:
  permission: {@admin_perm}
  permission message: &cNo permission.
  trigger:
    set {_u} to uid(argument 1)
    if {coins::%{_u}%} is not set:
      set {coins::%{_u}%} to 0
    add argument 2 to {coins::%{_u}%}
    send cc("&aGave &f%argument 2%&a coins to &f%argument 1%&a.") to player
    applyScoreboard(argument 1)

command /gemsgive <player> <number>:
  permission: {@admin_perm}
  permission message: &cNo permission.
  trigger:
    set {_u} to uid(argument 1)
    if {gems::%{_u}%} is not set:
      set {gems::%{_u}%} to 0
    add argument 2 to {gems::%{_u}%}
    send cc("&aGave &f%argument 2%&a gems to &f%argument 1%&a.") to player
    applyScoreboard(argument 1)

# Rank mode
command /rankmode <text>:
  permission: {@admin_perm}
  permission message: &cNo permission.
  trigger:
    set {_m} to lowercase argument 1
    if {_m} is "stored":
      set {rankmode} to "stored"
      send "&aRank mode set to &fstored&a." to player
      stop
    if {_m} is "permission":
      set {rankmode} to "permission"
      send "&aRank mode set to &fpermission&a." to player
      stop
    send "&cUse: /rankmode <stored|permission>" to player

# Rank set (stored mode)
command /rankset <player> <text>:
  permission: {@admin_perm}
  permission message: &cNo permission.
  trigger:
    if rankMode() is not "stored":
      send "&c/rankset only works in &fstored&c mode. Use /rankmode stored" to player
      stop

    set {_r} to argument 2
    if {ranks::%{_r}%::prefix} is not set:
      send "&cNo such rank: &f%{_r}%" to player
      stop

    set {_u} to uid(argument 1)
    set {rank::%{_u}%} to {_r}
    send "&aSet rank of &f%argument 1% &ato &f%{_r}%&a." to player
    applyTab(argument 1)
    applyScoreboard(argument 1)

# Mining blocks list manager
command /mineblocks <text> [<text>]:
  permission: {@admin_perm}
  permission message: &cNo permission.
  trigger:
    if argument 1 is "list":
      send "&7Mining XP blocks:" to player
      loop {xp::mine::blocks::*}:
        send "&8- &f%loop-value%" to player
      stop

    if argument 1 is "add":
      if argument 2 is not set:
        send "&cUse: /mineblocks add <material>" to player
        stop
      set {_m} to normMat(argument 2)
      if {_m} is in {xp::mine::blocks::*}:
        send "&eAlready in list: &f%{_m}%" to player
        stop
      add {_m} to {xp::mine::blocks::*}
      send "&aAdded: &f%{_m}%" to player
      stop

    if argument 1 is "remove":
      if argument 2 is not set:
        send "&cUse: /mineblocks remove <material>" to player
        stop
      set {_m} to normMat(argument 2)
      remove {_m} from {xp::mine::blocks::*}
      send "&aRemoved: &f%{_m}%" to player
      stop

    send "&cUse: /mineblocks <list|add|remove>" to player

# Tab editor (kept stable)
command /tabbar <text> [<text>] [<number>] [<text>]:
  permission: {@admin_perm}
  permission message: &cNo permission.
  trigger:
    if argument 1 is "show":
      send "&7Header lines:" to player
      loop {tab::header::*}:
        send cc("&8- &f%loop-index%&8: &f%loop-value%") to player
      send "&7Footer lines:" to player
      loop {tab::footer::*}:
        send cc("&8- &f%loop-index%&8: &f%loop-value%") to player
      stop

    if argument 1 is "header":
      if argument 2 is not set:
        send "&cUse: /tabbar header <add|set|clear> ..." to player
        stop

      if argument 2 is "clear":
        delete {tab::header::*}
        send "&aCleared tab header lines." to player
        stop

      if argument 2 is "add":
        if argument 4 is not set:
          send "&cUse: /tabbar header add <text>" to player
          stop
        add argument 4 to {tab::header::*}
        send "&aAdded header line." to player
        stop

      if argument 2 is "set":
        if argument 3 is not set:
          send "&cUse: /tabbar header set <index> <text>" to player
          stop
        if argument 4 is not set:
          send "&cUse: /tabbar header set <index> <text>" to player
          stop
        if argument 3 < 1:
          send "&cIndex must be 1 or higher." to player
          stop
        set {tab::header::%argument 3%} to argument 4
        send "&aSet header line &f%argument 3%&a." to player
        stop

    if argument 1 is "footer":
      if argument 2 is not set:
        send "&cUse: /tabbar footer <add|set|clear> ..." to player
        stop

      if argument 2 is "clear":
        delete {tab::footer::*}
        send "&aCleared tab footer lines." to player
        stop

      if argument 2 is "add":
        if argument 4 is not set:
          send "&cUse: /tabbar footer add <text>" to player
          stop
        add argument 4 to {tab::footer::*}
        send "&aAdded footer line." to player
        stop

      if argument 2 is "set":
        if argument 3 is not set:
          send "&cUse: /tabbar footer set <index> <text>" to player
          stop
        if argument 4 is not set:
          send "&cUse: /tabbar footer set <index> <text>" to player
          stop
        if argument 3 < 1:
          send "&cIndex must be 1 or higher." to player
          stop
        set {tab::footer::%argument 3%} to argument 4
        send "&aSet footer line &f%argument 3%&a." to player
        stop

    send "&cUnknown usage. Try: /tabbar show" to player

# =========================================================
# OPTIONAL: COMMAND AUTOCOMPLETE (UNCOMMENT IF SUPPORTED)
# Some Skript builds error on "tab completer". If yours errors, keep commented.
# =========================================================
# command /rankmode <text>:
#   tab completer:
#     if argument 1 is not set:
#       set tab completions to "stored", "permission"
#
# command /mineblocks <text> [<text>]:
#   tab completer:
#     if argument 1 is not set:
#       set tab completions to "list", "add", "remove"
#
# command /tabbar <text> [<text>] [<number>] [<text>]:
#   tab completer:
#     if argument 1 is not set:
#       set tab completions to "show", "header", "footer"
#     else if argument 1 is "header" or argument 1 is "footer":
#       if argument 2 is not set:
#         set tab completions to "add", "set", "clear"
